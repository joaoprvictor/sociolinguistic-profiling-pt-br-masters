# -*- coding: utf-8 -*-
"""extracting_simple_metrics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10A7ncfa2qaP2p9b7O0_wF6apDjxOFRsQ
"""

import re
import pandas as pd
from datetime import datetime
from sklearn.feature_extraction.text import CountVectorizer
import matplotlib.pyplot as plt
date = datetime.now().strftime('%Y-%m-%d')
import numpy as np

textOutputPath = "C:\\Users\\joaop\\Desktop\\Corpora\\C-Oral-Brasil\\dissertation_codes\\text_output_files\\charts\\" #path for final output
textInputPath = "C:\\Users\\joaop\\Desktop\\Corpora\\C-Oral-Brasil\\dissertation_codes\\text_output_files\\"

# reading the dataframe files
SexDF = pd.read_csv(textInputPath+f"metadataWithTranscriptionSEX_csv_{date}.csv")


AgeDF = pd.read_csv(textInputPath+f"metadataWithTranscriptionAGE_csv_{date}.csv")


SchoolingDF = pd.read_csv(textInputPath+f"metadataWithTranscriptionSCHOOLING_csv_{date}.csv")

# dividing the social variables to get different DFs
MaleDf = SexDF[SexDF.sex == "male"]
MaleDf.name = "male"
MaleDf.clean_utterance = MaleDf.clean_utterance.astype(str)
FemaleDf = SexDF[SexDF.sex == "female"]
FemaleDf.name = "female"

Df_1 = SchoolingDF[SchoolingDF.schooling == 1]
Df_1.name = 'schooling_1'
Df_2 = SchoolingDF[SchoolingDF.schooling == 2]
Df_2.name = 'schooling_2'
Df_3 = SchoolingDF[SchoolingDF.schooling == 3]
Df_3.name = 'schooling_3'

ADf = AgeDF[AgeDF.age == "A"]
ADf.name = 'ageA'
BDf = AgeDF[AgeDF.age == "B"]
BDf.name = 'ageB'
CDf = AgeDF[AgeDF.age == "C"]
CDf.name = 'ageC'
DDf = AgeDF[AgeDF.age == "D"]
DDf.name = 'ageD'
MDf = AgeDF[AgeDF.age == "M"]
MDf = MDf.replace(np.nan, "")
MDf.name = 'ageM'

def plot_ngram_frequency(df, column_name, ngram_range=(1,1), top_n=10, bar_color='blue', chart_title=None, file_name=None): #
    # Create a CountVectorizer with the desired n-gram range
    vectorizer = CountVectorizer(ngram_range=ngram_range, min_df=2, tokenizer=lambda text: text.split(" "), stop_words=None)

    # Fit the CountVectorizer to the text in the specified column of the DataFrame
    X = vectorizer.fit_transform(df[column_name])

    # Get the sum of each n-gram across all rows
    ngram_counts = X.sum(axis=0)

    # Convert the n-gram counts to a DataFrame
    ngram_df = pd.DataFrame(ngram_counts, columns=vectorizer.get_feature_names())

    # Get the top n-grams by frequency and sort them in descending order
    top_ngrams = ngram_df.T.sort_values(by=0, ascending=False)[:top_n]

    # Plot the top n-grams as a bar graph
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.bar(top_ngrams.index, top_ngrams[0], color=bar_color)
    ax.set_xlabel('N-gram')
    ax.set_ylabel('Frequency')
    ax.set_title(chart_title or f"Top {top_n} {ngram_range}-grams in {df.name}")
    plt.xticks(rotation=90)

    plt.savefig(textOutputPath+f"{file_name}.png", bbox_inches='tight')

    plt.show()

plot_ngram_frequency(MDf, "clean_utterance", ngram_range=(3,3), bar_color = 'darkolivegreen', chart_title=f"3-grams Frequency in {MDf.name}",file_name=f"3grams_in_{MDf.name}")

# allSociolects = pd.read_csv(textOutputPath+f"metadataWithTranscription_csv_{date}.csv")
# allSociolects = pd.read_csv(f"C:\\Users\\joaop\\Desktop\\Corpora\\C-Oral-Brasil\\dissertation_codes\\text_output_files\\metadataWithTranscription_csv_{date}.csv")
allSociolects = pd.read_csv(f"C:\\Users\\joaop\\Desktop\\Corpora\\C-Oral-Brasil\\dissertation_codes\\text_output_files\\metadataWithTranscription_csv_2023-09-26.csv")

allSociolects.columns

allSociolects = allSociolects[['unique_id_person', 'file', 'acronym', 'person_code',
       'sex', 'age', 'schooling', 'context', 'utterance', 'clean_utterance',
       'words_with_tags', 'lemmas', 'pos_tagged', 'total_words',
       'total_utterance', 'total_nonstandard_verb_agreement',
       'total_nonstandard_verb_conjugation', 'total_count_negation',
       'total_non_standard_plural', 'count_apheresis',
       'count_rhotacism', 'count_diminutive', #, 'count_senhor_senhora'
       'count_foreign_words', 'count_prepositions', 'count_pronouns',
       'count_interjections', 'combined_person_info']]

allSociolects['age'] = allSociolects['age'].str.replace("M", "A")
allSociolects['age'] = allSociolects['age'].str.replace("D", "C")

def groupAndPlotSum(df, column_a, column_b, bar_colors = None, file_name = None):
    """
    Groups a pandas DataFrame by the values in column_a, calculates the sum of the
    integer column values from column_b for each group, and returns a bar chart showing
    the sum of each group.

    Parameters:
    -----------
    df : pandas DataFrame
        The DataFrame to be grouped.

    column_a : str
        The name of the column to group by.

    column_b : str
        The name of the column to calculate the sum of.

    Returns: a bar plot, axis x = column_a values; axis y = grouped value
    --------
    None
    """
    columnB = " ".join(column_b.split("_")[1:])
    grouped = round((df.groupby(column_a)[column_b].sum()/df[column_b].sum())*100, 2)
    # grouped = (df.groupby(column_a)[column_b].sum()/df.groupby(column_a)["total_words"].sum())*100
    grouped.plot(kind='bar', color=bar_colors)
    # Set the y-axis tick label format to fixed notation with 2 decimal places
    plt.ticklabel_format(axis='y', style='plain', useOffset=False, useMathText=True)
    plt.title(f"Percentage of {columnB} per sociolect of {column_a}")
    plt.xlabel(column_a)
    plt.ylabel(f"Percentage of {columnB}")
    plt.savefig(textOutputPath+f"{file_name}.png", bbox_inches='tight')
    plt.show()

groupAndPlotSum(allSociolects, "age", "total_words", bar_colors=["lawngreen", 'limegreen', "darkgreen"], file_name = "ratio-words-age-sample")

groupAndPlotSum(allSociolects, "schooling", "total_words", bar_colors=["chocolate", "saddlebrown", "sandybrown"], file_name = "ratio-words-schooling")

groupAndPlotSum(allSociolects, "age", "total_words", bar_colors=['lawngreen', 'limegreen', 'darkgreen', 'seagreen', 'darkolivegreen'], file_name = "ratio-words-age")

def groupAndPlotSumPie90(df, column_a, column_b, bar_colors = None, file_name = None):
    """
    Groups a pandas DataFrame by the values in column_a, calculates the sum of the
    integer column values from column_b for each group, and returns a pie chart showing
    the percentage of each group.

    Parameters:
    -----------
    df : pandas DataFrame
        The DataFrame to be grouped.

    column_a : str
        The name of the column to group by.

    column_b : str
        The name of the column to calculate the sum of.

    Returns: a pie chart, each slice represents the percentage of grouped value (divide the chart vertically)
    --------
    None
    """
    columnB = " ".join(column_b.split("_")[1:])

    grouped = df.groupby(column_a)[column_b].sum()
    # Create the pie chart
    patches, texts, autotexts = plt.pie(grouped, labels=grouped.index, colors=bar_colors, autopct='%1.1f%%',startangle=90, counterclock=True, textprops={'fontsize': 12})
    # plt.pie(grouped, labels=grouped.index, colors=bar_colors, autopct='%1.1f%%', startangle=90, counterclock=False)
    plt.title(f"Percentage of {columnB} per sociolect of {column_a}")
    # Set the legend outside the pie chart and adjust its location to prevent overlapping with the title
    # plt.legend(loc='center left', bbox_to_anchor=(1, 0.5), fontsize=12)
    plt.axis('equal')
    # Set the style to classic and set the facecolor to white
    plt.style.use('classic')
    plt.gca().set_facecolor('white')
    plt.savefig(textOutputPath+f"{file_name}.png", bbox_inches='tight')
    plt.show()

def groupAndPlotSumPieGeneral(df, column_a, column_b, bar_colors = None, file_name = None):
    """
    Groups a pandas DataFrame by the values in column_a, calculates the sum of the
    integer column values from column_b for each group, and returns a pie chart showing
    the percentage of each group.

    Parameters:
    -----------
    df : pandas DataFrame
        The DataFrame to be grouped.

    column_a : str
        The name of the column to group by.

    column_b : str
        The name of the column to calculate the sum of.

    Returns: a pie chart, each slice represents the percentage of grouped value
    --------
    None
    """
    columnB = " ".join(column_b.split("_")[1:])

    grouped = df.groupby(column_a)[column_b].sum()
    # Create the pie chart
    patches, texts, autotexts = plt.pie(grouped, labels=grouped.index, colors=bar_colors, autopct='%1.1f%%',textprops={'fontsize': 12})
    # plt.pie(grouped, labels=grouped.index, colors=bar_colors, autopct='%1.1f%%', startangle=90, counterclock=False)
    plt.title(f"Percentage of {columnB} per sociolect of {column_a}")
    # Set the legend outside the pie chart and adjust its location to prevent overlapping with the title
    plt.axis('equal')
    # plt.legend(loc='center left', bbox_to_anchor=(1, 0.5), fontsize=12)
    # Set the style to classic and set the facecolor to white
    plt.style.use('classic')
    plt.gca().set_facecolor('white')
    plt.savefig(textOutputPath+f"{file_name}.png", bbox_inches='tight')
    plt.show()

groupAndPlotSumPieGeneral(allSociolects, "schooling", "total_words", bar_colors=["chocolate", "saddlebrown", "sandybrown"], file_name="schooling-words-ratio")

groupAndPlotSumPieGeneral(allSociolects, "age", "total_words", bar_colors=['lawngreen', 'limegreen', 'darkgreen', 'seagreen', 'darkolivegreen'], file_name="age-words-ratio")

groupAndPlotSumPie90(allSociolects, "sex", "total_words", bar_colors=['tomato', 'firebrick'], file_name="sex-words-ratio")

"""# Extracting min, max, average, variance and boxplot"""

# Select numerical columns
allSociolects.schooling = allSociolects.schooling.astype(str)
numerical_cols = allSociolects.select_dtypes(include='number')
# Extract minimum and maximum values
min_values = numerical_cols[numerical_cols != 0].min()
max_values = numerical_cols.max()

print("Minimum values:")
print(min_values)
print("\n======\nMaximum values:")
print(max_values)

# Extract average and variance values
average_values = numerical_cols.mean()
variance_values = numerical_cols.var()

print("Average values:")
print(round(average_values, 2))
print("\n=====\nVariance values:")
print(round(variance_values, 2))

stderror_values = numerical_cols.std()

print("Standard error values:")
print(round(stderror_values, 2))

# Generate boxplots for each column
for column in numerical_cols:
    plt.figure()  # Create a new figure for each boxplot
    plt.boxplot(numerical_cols[column])
    plt.xlabel(column)
    plt.ylabel('Values')
    plt.title(f'Boxplot of {column}')

# Display the boxplots
plt.show()

# Generate box plots per numerical column, separated by the categorical column
categorical_col = 'sex'

for numerical_col in numerical_cols:
    plt.figure()  # Create a new figure for each boxplot
    allSociolects.boxplot(column=numerical_col, by=categorical_col)
    numTitle = numerical_col.split("_")
    numTitle = " ".join(numTitle)
    plt.xlabel(categorical_col)
    plt.ylabel(numTitle)
    # plt.title(f'Boxplot of {numerical_col} by {categorical_col}')

# Display the boxplots
plt.show()

import numpy as np

# Sample numerical data
data = [10, 15, 20, 25, 30]

# Centralize the data
centralized_data = data - np.mean(data)

# Divide by the standard deviation twice
standardized_data = centralized_data / np.std(centralized_data)
standardized_data2 = standardized_data/ np.std(centralized_data)

print("Original Data:", data)
print("Standardized Data:", standardized_data)
print("Standardized Data2:", standardized_data2)